# 模块化

1. 前端模块化解决了前端开发中什么问题
	1、是命名冲突：在传统的前端开发中，所有的代码都是定义在全局作用域中的，容易发生变量名冲突的问题。使用模块化可以将代码封装在独立的作用域中，避免了命名冲突。
	2、代码复用：前端开发中存在大量的重复代码，例如常见的工具函数、UI组件等。使用模块化可以将这些常用的代码封装为一个模块，并在需要使用时直接引入即可，提高了代码的复用性。
	3、前端开发中存在大量的依赖关系，例如某些模块依赖于其他模块。使用模块化可以方便地管理这些依赖，当一个模块被修改时，只需要重新打包该模块及其依赖即可，而不需要重新打包整个应用。
	4、前端应用的代码规模越来越大，代码维护难度也越来越高。使用模块化可以将应用拆解成多个独立的模块，每个模块只负责特定的功能，降低了代码的耦合度，方便了代码的维护和升级。
	总之，提高了代码的可维护性、可重用性和可扩展性。

🌟➡️产生需求：需要一个模块化的标准和可以用来自动加载模块的基础库

前端模块化演变
1、commonjs，nodejs提出的标准：同步加载
		· 一个文件就是一个模块；每个模块都有独立的作用域；通过module.exports导出成员；通过require函数载入模块。
		· CommonJS规范采用同步加载模块的方式，这样会阻塞浏览器的主线程，导致应用的性能受到影响
2、AMD 异步的模块定义规范。同期推出了requirejs的库，实现了AMD规范。   实现使用相对比较复杂
3、淘宝推出的Seajs库，实现了Seajs官方给出的标准CMD，全程commonjsDefinmation通用的模块定义规范，标准类似commonjs，使用上类似requirejs，实际上可以算是重复的轮子，后来他的写法也被requirejs兼容了

4、ESModule2015，从语言层面实现了模块化，主流，但是不是所有浏览器都兼容，所以需要webpack打包工具
	1 - script标签中添加type=module属性，就可以以esmodule的标准执行其中的js代码
	2 - ESM自动采用严格模式，忽略usestrict
	3 - 每个ESM 都是运行在单独的私有作用域中
	4 - 外部js文件是通过CORS的方式去请求的，另外CORS不支持文件的方式访问，所以需要通过http-server的方式让页面工作起来
	5 - ESM的script标签会延迟执行脚本，相当于defer属性
	⚠️：export 具名导出   例：export {}  	import {} from ‘’;    export后的双花括号并不是对象的意思，导入也不是解构，而是固定写法
	6 - 导出只是将值的引用关系导出到了外部，而不是拷贝，且导出的成员是只读的成员
	7 - 可以动态导入使用import()

模块打包工具的由来：
	1 - 需要编译代码，将新特性代码转化为大部分情况都可以运行的代码
	2 - 模块打包，减少请求
	3 - 支持不同种类的资源文件类型，样式图片字体都看作模块，便于维护

webpack 核心特性
	1 - 模块打包器
	2 - 模块加载器，需要兼容的地方，进行编译转换
	3 - 代码拆分，将应用中所有的代码按照我们的需要去打包；比如初次运行需要的包打包到一起，其他的模块单独存放，到需要时异步加载｜增量加载｜渐进式加载
	4 - 模块资源，允许在js中以模块化的方式载入任意类型的文件，例如在js中引入css文件，实际工作中以style标签的方式进行工作
	总：打包工具解决的是前端整体的模块化，并不单指js模块化
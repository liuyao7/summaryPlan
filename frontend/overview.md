# 前端基础
1. 前端是什么？
    - 在业内，前端通常指的是负责开发PC和H5页面的程序员，而所有直接展示给用户的页面则被统称为端页面。

2. 前端的技术栈有什么？
    - 前端三剑客：html、css、js;
    - 高级框架：Vue、React、AngularJS;
    - 打包工具：webpack;
    - 编译工具：babel;
    - 代码规范：eslint;
    - 版本控制：git;
    - 包管理工具：npm、yarn;

3. 高级框架产生的背景是什么？
    - 主要是为了解决现代web开发中的复杂性和不断增长的需求
    - 几个具体原因：
        - 组件化开发；
        - 虚拟DOM，高效的dom更新；
        - 单项数据流和状态管理；
        - 丰富的生态系统和工具链，如路由、状态管理、构建工具等；
        - 增强的开发者体验；
        - 社区和支持；
        - 跨平台能力；
    - 总之，高级框架的出现提效、简化开发流程、增强了代码的维护性和扩展性。

---------------------------------------------------------------------------------------------------------------

# 模块化
1. 原生模块化的弊端：
    - 原生的es6支持模块化（import/export），但是一些旧的浏览器不支持。
    - 原生模块会为每个import语句生成一个http请求，导致性能问题。
    - 不支持非js模块化（css、图片）。
    - 更早之前的项目开发中存在很多问题，比如全局变量污染、命名冲突、依赖管理等。
2. 模块化工具webpack、rollup：
    - 作用域隔离；
    - 自动依赖管理；
    - 代码分割；
    - 打包优化；
    - 支持多种模块格式；
    - 增强开发体验
    - 插件和扩展性；


html\css\js --> 模块化 --> npm包管理 --> 工具整合打包 --> 上线浏览器运行

----------------------------------------------------------------------------------------------------------------
模块化：esmodule、commonjs、amd、umd，为了处理全局变量污染、依赖和维护成本问题。
esm和commonjs的区别：
 - esm在编译时解析依赖，commonjs在运行时解析依赖。
 - esm支持异步加载，模块顶层是独立作用域，不与全局作用域共享。
 - commonjs同步加载模块，模块顶层是文件作用域，与全局作用域共享。

 es6在编译阶段静态解析，这意味着它允许编译器进行更高效的优化，例如树摇tree-shaking和静态分析。
  - 总结：静态特性、异步加载
commonjs在运行时解析依赖，这意味着require函数可以在任何地方调用，包括条件语句中。
  - 总结：动态特性、同步加载

------------------------------------
# npm
npm:基于nodejs的包管理工具。由两个部分组成，一个是cli用于发布和下载，另一个是在线仓库。 
package.json: 描述项目信息、依赖、脚本等。npm init初始化就会生成。
npm script：执行脚本命令。
{
  "scripts": {
    "build": "tsc",
    "format": "prettier --write **/*.ts",
    "format-check": "prettier --check **/*.ts",
    "lint": "eslint src/**/*.ts",
    "pack": "ncc build",
    "test": "jest",
    "all": "npm run build && npm run format && npm run lint && npm run pack && npm test"
  }
}
eslint src/**/*.ts为什么可以执行，当npm scripts执行时，会查找node_modules/.bin目录下的可执行文件，这些文件其实是可执行的文件链接，由安装在项目中的npm包导出，比如
"bin": {
    "eslint": "./bin/eslint.js"
},
这是由package.json中的bin字段指定的。
直接在命令行执行npx eslint src/**/*.ts也可以，npx会查找node_modules/.bin目录下的可执行文件，并执行。

## npm link
专门用于调试本地包。
使用步骤：1.正在开发的包npm init，配置包名name、main（主要是向后兼容老工具）、exports（同时支持多种引入方式）、type
2.在当前包中执行npm link，会创建一个全局符号链接，指向当前包的路径。
3.在需要使用的包中执行npm link <package-name>，会创建一个符号链接，指向全局的包。

## package.json
name: 包名
version: 版本号
description: 描述
main: 入口文件(和exports不冲突，exports优先级更高)
type: 模块类型（module、commonjs）,指定整个包的默认模块类型，如果在esmodule中使用commonjs，需要使用.cjs扩展名。
scripts: 脚本命令
keywords: 关键字
author: 作者
license: 许可证
dependencies: 依赖包
devDependencies: 开发依赖包
peerDependencies: 对等依赖包
bin: 可执行文件
files: 发布到npm上的文件
repository: 代码仓库
homepage: 项目主页
bugs: 问题反馈
engines: 运行环境
private: 是否私有
publishConfig: 发布配置
workspaces: 工作区
exports: 导出配置


---------------------------------------------------------------------------------------------
webpack
为什么产生？解决了什么问题？怎么使用？运行原理？
打包、依赖分析、代码分割、优化、热更新、插件化
解决了上述问题
webpack其实是别人造的一个轮子
几个基本概念：
        - entry依赖开始分析的入口（本身具备的功能）
            - 开始之后遇到解析不了的文件交给loader处理（配置）
            - 对某些自定义的规则交给plugin扩展（自定义）
            - 
        - output依赖打包后的输出位置
            module、chunk、loader、plugin
处理依赖关系，自动处理，确保所有需要的文件都正确加载。
文件打包，优势：可以把js、css、图片等等打包成一个或几个文件，减少请求，提高加载速度。
模块开发，优势：便于维护，好开发，组织代码、分离功能。
优化性能，可以进行代码压缩分割去重、懒加载。
热更新，不用刷新整个页面就能看到变化。

webpack打包后runtime
__webpack_require__：加载模块的函数，用于加载模块并执行其代码。
__webpack_require__.d：在模块的 exports 对象上定义导出的属性，并确保它们是可枚举的。
__webpack_require__.o：检查对象是否具有某个属性。
__webpack_require__.r：将模块标记为 harmony 模块，以便在模块执行时可以正确处理导出。

<a href="https://mp.weixin.qq.com/s/_rl5V6XX8fw_JO_RTfVaYA">webpack八千字长文解析</a>
1. webpack对模块的转换：
    - 我们的模块被转换为了立即自执行函数，进行模块的创建和链接；（runtime 代码）
    - 所有模块组装成对象作为函数的参数传入。对象的构成{[文件的路径]：[被包装后的模块内容]}；
    - 每个模块都被构造的函数包裹。（模块代码的转换）
2. 执行时的模块链接：主要通过__webpack_require__函数，将模块的依赖关系建立起来，形成一个依赖树。
3. 模块动态加载的处理：通过script标签动态加载，下载后先将模块缓存到modules中，创建和获取模块对象也是通过__webpack_require__完成。 
4. 打包后的加载顺序：runtime -> 主应用文件 -> 异步模块
runtimeChunk单独打包，简单理解就是把main.js中的所有模块，通过回调注册到runtimeChunk中的moudles上。

<!-- ast（Abstract Syntax Tree） -->
是什么？源代码语法的抽象表示，以树状的形式表现编程语言的语法结构，树上的每个节点都是表示源代码中的一种结构。
应用：代码语法的检查、代码风格、代码格式化、代码高亮、错误提示、自动补全代码等场景。

<!-- webpack构建核心流程 -->
1. 初始化阶段：
    - 初始化参数：从配置文件和Shell语句中读取与合并参数，得出最终的参数；
    - 创建编译器对象：用上一步得到的参数初始化Compiler对象；
    - 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化RuleSet集合、加载配置的插件等；
    - 开始编译：执行对象的run方法开始执行编译。
    - 确定入口：根据配置中的entry找出入口文件，调用compilition.addEntry将入口文件转换为dependence对象；
2. 构建阶段：
    - 编译模块make：根据entry对应的dependence创建module对象，调用loader将模块转译为标准的js内容，调用js解释器将内容转换为ast对象，从中找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
    - 完成模块的编译：从上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的依赖关系图；
3. 生成阶段：
    - 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表，这部是可以修改输出内容的最后机会；
    - 写入文件系统：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

### 常见问题
1. webpack编译过程会将源码解析为AST吗？webpack与babel分别实现了什么？
    - 构建阶段会读取源码，解析为AST集合。
    - webpack读出AST之后仅遍历ast集合，不进行转换，babel会遍历ast集合，进行转换。

2. webpack编译过程中，如何识别资源对其他资源的依赖？
    - webpack遍历AST集合过程中，识别require/import之类的导入语句，确定模块对其他资源的依赖关系，也就是说 依赖是通过遍历AST识别的。
3. 相对于grunt、gulp等流式构建工具，为什么webpack会被认为是新一代的构建工具？
    - Grunt、gulp仅仅执行开发者预定义的任务流；而webpack则深入处理资源的内容，功能上更加强大。

# Tapable
## 是什么？
Tapable 是一个用于创建可插拔系统的库，它的主要功能是提供钩子（hooks），让开发者能够在代码的特定点插入自定义逻辑。
webpack的核心依赖，是一个事件流机制库，提供了一种灵活的方式来管理事件和回调函数。
## 为什么？
webpack需要一种灵活的方式来管理构建过程中的各种事件和回调函数，以便在构建过程中执行各种操作。
## 核心概念
1. hook：钩子，是webpack构建过程中的关键点，可以在这些关键点上注册回调函数。
2. tap：注册一个插件，将回调函数注册到钩子上。
3. call：执行插件，在构建过程中触发钩子，执行所有注册到该钩子上的回调函数。
4. intercept：拦截器，可以在执行钩子之前或之后执行一些操作。
## 做了什么？
1.tabpable对外暴露9种hook钩子，核心方法是注册、执行、拦截器；
2.tabable实现方式就是通过根据钩子和注册类型拼接字符串传入Function构造函数创建一个新的Fn对象。<a src="https://github.com/webpack/tapable/issues/162">为什么是newFunction而不是遍历调用函数</a>
3.webpack通过tapable来对整个构建步骤进行了流程化的管理，实现了对每个构建步骤都能进行灵活定制化需求；
## 用法
利用tapable构建一个插件，在class中定义多个hook，每个hook可以注册多个插件，执行时按照注册顺序执行插件。先注册再执行
## 钩子类型
1. SyncHook：同步钩子，只允许注册一次，每次执行都会执行所有注册的插件。
2. AsyncParallelHook：异步并行钩子，允许多次注册，每次执行时会并行执行所有注册的插件。
3. AsyncSeriesHook：异步串行钩子，允许多次注册，每次执行时会按顺序执行所有注册的插件。
4. BailHook：快速失败钩子，允许多次注册，如果某个插件返回了一个非undefined的值，则后续插件将不再执行。
5. LoopHook：循环钩子，允许多次注册，每次执行时会循环执行所有注册的插件，直到没有插件返回非undefined的值为止。



<!-- experience -->
开发项目过程中遇到不熟悉的或者难点的解决办法：首先在项目的初始阶段，比如需求评审或者预沟通阶段，需要根据项目背景和收益去判断需求的合理性，如果需求不合理，需要和产品沟通是否可以修改实现方式，如果
需求合理，有必要的情况下，在需求评审通过后及时去调研实现的一个方案，最好写一个demo去验证，然后根据demo设计技术方案，技术评审通过后，在开始开发。
如果开发过程中遇到不熟悉的或者难点，首先去查内部文档，公司沟通群里问是否有人做过类似的，如果都没有，网上搜索或者问aigc，如果都不行，自己解决，但是需要设置一个时间节点，如果超过时间节点就向上同步，
避免影响项目进度。

<!-- 工作中如何对项目进行优化 -->
提升效率：比如抽离组件，封装hooks，及时补充文档，写通用样式，踩坑记录，代码规范统一
在开发项目的过程中也不能急于求成，先走再跑，先保证功能实现，再考虑优化，比如组件拆分是否合理，公共常量是不是需要抽离出来单独维护，代码性能是否能够优化
在封装组件的过程中，考虑组件封装好之后好不好用，封装的太多了是不是不好用，保持原子化，避免过度封装，通用性如何，组件扩展性咋样，怎么设计更合理，封装之后文档是不是完善，有没有考虑边界条件，测试通过上线稳定之后，是否需要在团队内部同步这个组件，避免重复开发。
封装组件，不要把业务代码封装到通用组件中，考虑props传入。

webpack学习节奏：
前端发展进程 => 模块化 => 组件化 => webpack构建打包 => 熟悉基本配置 => 了解runtime运行时包 => 具体构建流程 => plugin了解 => ast了解 => tapable了解 => webpack调试，验证构建调用栈


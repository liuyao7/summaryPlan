js

1、六种简单数据类型，一种复杂数据类型
2、函数在es中被认为是一个对象
3、Null 是一个空对象指针
4、undefined：未初始化的变量会被typeof操作符解释为undefined
5、undefined 值是由null 值派生而来的，，因此ECMA-262 将它们定义为表面上相等
6、parseInt空字符串返回NaN
7、模板字符串所有插入的值都会使用toString()强制转型为字符串
8、获取原始的模板字面量内容，使用默认的String.raw 标签函数
9、Symbol()函数不能与new 关键字一起作为构造函数使用
10、如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键
let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
11、instanceof 操作符会使用Symbol.hasInstance 函数来确定关系，这个属性定义在Function 的原型上，因此默认在所有函数和类上都可以调用。由于instanceof操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数
12、Symbol.isConcatSpreadable：一个布尔值，如果是true，则意味着对象应，该用Array.prototype.concat()打平其数组元素，false 或假值会导致整个对象被追加到数组末尾
13、Object.toString===Function.prototype.toString.     Object.prototype.__proto__ = null
14、按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数，按位非的最终效果是对数值取反并减1，位操作是在数值的底层表示

垃圾回收策略
1、标记清理
2、引用计数
3、解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。
4、使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存

Fiddler打开会自动修改系统的网络代理，app修改wifi;

基本引用类型
1、Date.now() === (new Date()).valueOf()
2、每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象
3、当第二行访问s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3 步：
(1) 创建一个String 类型的实例；
(2) 调用实例上的特定方法；
(3) 销毁实例。
这种行为可以让原始值拥有对象的行为

String
1、console.log([...message]); // ["a", "b", "c", "d", “e”];字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。

Global
1、像undefined、NaN 和Infinity 等特殊值都是Global 对象的属性。此外，所有原生引用类型构造函数
2、window对象是golbal对象的代理。

迭代器
1、可迭代对象：元素有限；无歧义的遍历顺序
2、很多内置类型支持了iterator迭代接口、字符串、数组、映射、集合、domnodelist、arguments
3、Symbol.iterator返回迭代器工厂函数，调用函数返回迭代器，
4、接收可迭代对象的原生语言特性包括：
 for-of 循环
 数组解构
 扩展操作符
 Array.from()
 创建集合
 创建映射
 Promise.all()接收由期约组成的可迭代对象
 Promise.race()接收由期约组成的可迭代对象
 yield*操作符，在生成器中使用
5、通过创建迭代器并调用next()方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达done: true 状态，后续调用next()就一直返回同样的值了：

构造函数
1、构造函数创建不同实例上的函数虽然同名却不相等

Promise
1、await 关键字会暂停执行异步函数后面的代码，让出JavaScript 运行时的执行线程。

定时器
1、setTimeout()的第二个参数只是告诉JavaScript 引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完才能执行。

性能
1、在JavaScript 中，页面中事件处理程序的数量与页面整体性能直接相关。原因有很多。首先，每个函数都是对象，都占用内存空间，对象越多，性能越差。其次，为指定事件处理程序所需访问DOM 的次数会先期造成整个页面交互的延迟。

XMLHttpRequest	
1、new XMLHttpRequest().    Xhr.onreadystatechange.   	xhr.readystate		xhr.status	xhr.open		xhr.send		xhr.responseText		xhr.setRequestHeader		
2、POST 请求相比GET 请求要占用更多资源。从性能方面说，发送相同数量的数据，GET 请求比POST 请求要快两倍。
3、FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过XHR发送
4、使用FormData 的另一个方便之处是不再需要给XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为FormData 实例传入的数据类型并自动配置相应的头部。

JSONP
1、JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除JSONP 没有其他办法。在使用不受控的Web 服务时，一定要保证是可以信任的。
2、第二个缺点是不好确定JSONP 请求是否失败。虽然HTML5 规定了<script>元素的onerror 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的。

浏览器会对跨域资源进行同源策略限制，防止恶意脚本进行跨域攻击。当图片被缓存到浏览器缓存中时，如果该图片是跨域资源，并且在请求该图片时没有设置正确的跨域请求头，那么在后续通过 img 标签加载该图片时，就无法显示出来。
如果要在使用 img 标签加载跨域图片时能够正常显示，需要设置图片的 CORS（跨域资源共享）属性。CORS 允许浏览器跨域访问资源，并允许服务器通过设置响应头来授权访问。在 HTML 中，可以使用 crossorigin 属性来设置图片的 CORS 属性。例如：

移动端适配
1、在移动适配中，为了方便计算和使用rem单位，常常会将根元素的字体大小乘以一个比例因子，通常为100。这是因为CSS中的rem单位是相对于根元素的字体大小计算的。
假设我们将根元素的字体大小设置为100px，那么1rem就等于100px。通过这种设置，我们可以更方便地计算其他元素的大小，比如一个宽度为2rem的元素实际上就等于200px。
为什么选择乘以100呢？这是因为我们通常将根元素的字体大小设置为一个比较小的值，比如16px，这样在大多数设备上都能够正常显示。而乘以100可以使我们在CSS中使用的单位更加整洁，不需要频繁地使用小数点。

Cookie
Cookie是根据域名和路径进行识别和管理的，浏览器会根据请求的域名和路径来判断是否发送对应的Cookie到服务器。当请求经过代理服务器时，代理服务器会将请求转发到目标服务器，但不会自动将cookie带到目标服务器

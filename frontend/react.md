React
1. React 在移除一个组件时，也会销毁它的 state。只有当你在相同的位置渲染相同的组件时，React 才会一直保留着组件的 state
2. 永远要将组件定义在最上层并且不要把它们的定义嵌套起来

对state进行保留和重置
* 只要在相同位置渲染的是相同组件， React 就会保留状态。
* state 不会被保存在 JSX 标签里。它与你在树中放置该 JSX 的位置相关联。
* 你可以通过为一个子树指定一个不同的 key 来重置它的 state。
* 不要嵌套组件的定义，否则你会意外地导致 state 被重置。

在组件间进行保留和重置
* 当你想要整合两个组件时，将它们的 state 移动到共同的父组件中。
* 然后在父组件中通过 props 把信息传递下去。
* 最后，向下传递事件处理程序，以便子组件可以改变父组件的 state 。
* 考虑该将组件视为“受控”（由 prop 驱动）或是“不受控”（由 state 驱动）是十分有益的

选择state结构
* 如果两个 state 变量总是一起更新，请考虑将它们合并为一个。
* 仔细选择你的 state 变量，以避免创建“极难处理”的 state。
* 用一种减少出错更新的机会的方式来构建你的 state。
* 避免冗余和重复的 state，这样您就不需要保持同步。
* 除非您特别想防止更新，否则不要将 props 放入 state 中。
* 对于选择类型的 UI 模式，请在 state 中保存 ID 或索引而不是对象本身。
* 如果深度嵌套 state 更新很复杂，请尝试将其展开扁平化。

迁移状态逻辑至Reducer
* 把 useState 转化为 useReducer：
    1. 通过事件处理函数 dispatch actions；
    2. 编写一个 reducer 函数，它接受传入的 state 和一个 action，并返回一个新的 state；
    3. 使用 useReducer 替换 useState；
* Reducers 可能需要你写更多的代码，但是这有利于代码的调试和测试。
* Reducers 必须是纯净的。
* 每个 action 都描述了一个单一的用户交互。
* 使用 Immer 来帮助你在 reducer 里直接修改状态。

使用ref操作dom
* Refs 是一个通用概念，但大多数情况下你会使用它们来保存 DOM 元素。
* 你通过传递 `<div ref={myRef}>` 指示 React 将 DOM 节点放入 myRef.current。
* 通常，你会将 refs 用于非破坏性操作，例如聚焦、滚动或测量 DOM 元素。
* 默认情况下，组件不暴露其 DOM 节点。 您可以通过使用 forwardRef 并将第二个 ref 参数传递给特定节点来暴露 DOM 节点。
* 避免更改由 React 管理的 DOM 节点。
* 如果你确实修改了 React 管理的 DOM 节点，请修改 React 没有理由更新的部分。

使用ref引用值
* ref 是一个应急方案，用于保留不用于渲染的值。 你不会经常需要它们。
* ref 是一个普通的 JavaScript 对象，具有一个名为 current 的属性，你可以对其进行读取或设置。
* 你可以通过调用 useRef Hook 来让 React 给你一个 ref。
* 与 state 一样，ref 允许你在组件的重新渲染之间保留信息。
* 与 state 不同，设置 ref 的 current 值不会触发重新渲染。
* 不要在渲染过程中读取或写入 ref.current。这使你的组件难以预测。

使用Effect同步
* 与事件不同，Effect 是由渲染本身，而非特定交互引起的。
* Effect 允许你将组件与某些外部系统（第三方 API、网络等）同步。
* 默认情况下，Effect 在每次渲染（包括初始渲染）后运行。
* 如果 React 的所有依赖项都与上次渲染时的值相同，则将跳过本次 Effect。
* 不能随意选择依赖项，它们是由 Effect 内部的代码决定的。
* 空的依赖数组（[]）对应于组件“挂载”，即添加到屏幕上。
* 仅在严格模式下的开发环境中，React 会挂载两次组件，以对 Effect 进行压力测试。
* 如果 Effect 因为重新挂载而中断，那么需要实现一个清理函数。
* React 将在下次 Effect 运行之前以及卸载期间这两个时候调用清理函数。

🌟 通常，当在相同的位置渲染相同的组件时，React 会保留状态。通过将 userId 作为 key 传递给 Profile 组件，使  React 将具有不同 userId 的两个 Profile 组件视为两个不应共享任何状态的不同组件。每当 key（这里是 userId）变化时，React 将重新创建 DOM，并 重置 Profile 组件和它的所有子组件的 state。现在，当在不同的个人资料之间导航时，comment 区域将自动被清空。

🌟 在渲染期间更新组件时，React 会丢弃已经返回的 JSX 并立即尝试重新渲染。为了避免非常缓慢的级联重试，React 只允许在渲染期间更新 同一 组件的状态。

🌟 当你决定将某些逻辑放入事件处理函数还是 Effect 中时，你需要回答的主要问题是：从用户的角度来看它是 怎样的逻辑。如果这个逻辑是由某个特定的交互引起的，请将它保留在相应的事件处理函数中。如果是由用户在屏幕上 看到 组件时引起的，请将它保留在 Effect 中。

你可能不需要Effect
* 如果你可以在渲染期间计算某些内容，则不需要使用 Effect。
* 想要缓存昂贵的计算，请使用 useMemo 而不是 useEffect。
* 想要重置整个组件树的 state，请传入不同的 key。
* 想要在 prop 变化时重置某些特定的 state，请在渲染期间处理。
* 组件 显示 时就需要执行的代码应该放在 Effect 中，否则应该放在事件处理函数中。
* 如果你需要更新多个组件的 state，最好在单个事件处理函数中处理。
* 当你尝试在不同组件中同步 state 变量时，请考虑状态提升。
* 你可以使用 Effect 获取数据，但你需要实现清除逻辑以避免竞态条件。

响应式Effect的生命周期
* 组件可以挂载、更新和卸载。
* 每个 Effect 与周围组件有着独立的生命周期。
* 每个 Effect 描述了一个独立的同步过程，可以 开始 和 停止。
* 在编写和读取 Effect 时，要独立地考虑每个 Effect（如何开始和停止同步），而不是从组件的角度思考（如何挂载、更新或卸载）。
* 在组件主体内声明的值是“响应式”的。
* 响应式值应该重新进行同步 Effect，因为它们可以随着时间的推移而发生变化。
* 检查工具验证在 Effect 内部使用的所有响应式值都被指定为依赖项。
* 检查工具标记的所有错误都是合理的。总是有一种方法可以修复代码，同时不违反规则。
理想情况下，应用程序中的大多数 Effect 最终都应该由自定义 Hook 替代，无论是由你自己编写还是由社区提供。自定义 Hook 隐藏了同步逻辑，因此调用组件不知道 Effect 的存在。随着你继续开发应用程序，你将开发出一套可供选择的 Hooks，并且最终将不再经常在组件中编写 Effect。

将事件从Effect中分开
* 事件处理函数在响应特定交互时运行。
* Effect 在需要同步的时候运行。
* 事件处理函数内部的逻辑是非响应式的。
* Effect 内部的逻辑是响应式的。
* 你可以将非响应式逻辑从 Effect 移到 Effect Event 中。
* 只在 Effect 内部调用 Effect Event。
* 不要将 Effect Event 传给其他组件或者 Hook。
* if (notificationTimeoutId !== undefined) {
*         clearTimeout(notificationTimeoutId);
*       }

移除Effect依赖
* 依赖应始终与代码匹配。
* 当你对依赖不满意时，你需要编辑的是代码。
* 抑制 linter 会导致非常混乱的错误，你应该始终避免它。
* 要移除依赖，你需要向 linter “证明”它不是必需的。
* 如果某些代码是为了响应特定交互，请将该代码移至事件处理的地方。
* 如果 Effect 的不同部分因不同原因需要重新运行，请将其拆分为多个 Effect。
* 如果你想根据以前的状态更新一些状态，传递一个更新函数。
* 如果你想读取最新值而不“反应”它，请从 Effect 中提取出一个 Effect Event。
* 在 JavaScript 中，如果对象和函数是在不同时间创建的，则它们被认为是不同的。
* 尽量避免对象和函数依赖。将它们移到组件外或 Effect 内。


好的自定义 Hook 通过限制功能使代码调用更具声明性。
如果你的自定义 Hook API 没有约束用例且非常抽象，那么在长期的运行中，它引入的问题可能比解决的问题更多。

* 自定义 Hook 让你可以在组件间共享逻辑。
* 自定义 Hook 命名必须以后跟一个大写字母的 use 开头。
* 自定义 Hook 共享的只是状态逻辑，不是状态本身。
* 你可以将响应值从一个 Hook 传到另一个，并且他们会保持最新。
* 每次组件重新渲染时，所有的 Hook 会重新运行。
* 自定义 Hook 的代码应该和组件代码一样保持纯粹。
* 把自定义 Hook 收到的事件处理函数包裹到 Effect Event。
* 不要创建像 useMount 这样的自定义 Hook。保持目标具体化。
* 如何以及在哪里选择代码边界取决于你。

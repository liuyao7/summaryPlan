# Nodejs环境

## Node.js的架构
┌─────────────────────────────────────┐
│         JavaScript 代码              │  <-- 单线程
├─────────────────────────────────────┤
│           V8 引擎                   │  <-- 执行 JS
├─────────────────────────────────────┤
│         Node.js Bindings            │  <-- C++ 绑定
├─────────────────────────────────────┤
│           libuv                     │  <-- 异步 I/O
│  ┌──────────┬──────────┬─────────┐ │
│  │ Thread   │ Thread   │ Thread  │ │  <-- 线程池
│  │ Pool     │ Pool     │ Pool    │ │
│  └──────────┴──────────┴─────────┘ │
└─────────────────────────────────────┘

## IO操作的实际过程
// 当你写这段代码时
fs.readFile('large-file.txt', (err, data) => {
  console.log('文件读取完成');
});
console.log('继续执行');

// 实际发生的事情：
// 1. fs.readFile 调用 -> 传递给 libuv
// 2. libuv 分配一个线程池中的线程去读文件
// 3. JavaScript 主线程继续执行 console.log('继续执行')
// 4. 文件读取完成后，libuv 将回调函数放入事件队列
// 5. 事件循环检查队列，执行回调

## 总结
I/O 操作不在 JavaScript 主线程执行
I/O 由 Node.js 的底层（libuv）处理
JavaScript 只负责发起 I/O 和处理完成回调
这就是为什么 JavaScript 单线程也能高效处理并发

# 浏览器环境
浏览器中的一些异步操作是由浏览器内置的Web API处理的。例如，setTimeout、setInterval、DOM事件、AJAX请求等。这些API会在必要时将任务交给操作系统或浏览器的底层机制处理，然后通过事件循环机制将结果返回给JavaScript。

## 架构
（以 Chrome 为例）
┌─────────────────────────────────────────┐
│          Browser Process                 │  <-- 主进程
├─────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │Renderer │  │Renderer │  │Network  │ │
│  │Process  │  │Process  │  │Process  │ │  <-- 子进程
│  │(Tab 1)  │  │(Tab 2)  │  │         │ │
│  └─────────┘  └─────────┘  └─────────┘ │
└─────────────────────────────────────────┘

// 每个 Renderer Process 内部
┌─────────────────────────────────────────┐
│          Renderer Process                │
├─────────────────────────────────────────┤
│  Main Thread (UI Thread)                │  <-- JS 执行
│  Compositor Thread                      │  <-- 合成
│  Worker Threads                         │  <-- Web Workers
│  Raster Threads                         │  <-- 光栅化
└─────────────────────────────────────────┘

## dom事件也是异步操作
当用户与DOM交互（例如点击按钮）时，浏览器会捕获该事件并将其放入事件队列。JavaScript代码执行完毕后，事件循环会检查事件队列，并执行事件处理程序。

## 异步API
setTimeout、setInterval、Promise、async/await等都是浏览器提供的异步API，它们允许JavaScript代码在不阻塞主线程的情况下执行异步操作。

## 执行栈
执行栈（call stack）（后进先出）用于存储在脚本执行过程中创建的所有执行上下文。当一个函数被调用时，它的执行上下文会被压到栈中；当函数执行完毕之后，它的执行上下文会从栈中弹出，当执行栈为空时，事件循环会从任务队列中取出下一个任务并放入执行栈中执行。

## 事件循环
事件循环的主要作用是监控调用栈和任务队列，并在调用栈为空时将任务队列中的任务压入调用栈执行。（先进先出）工作流程：
1. 检查执行栈：如果执行栈不为空，事件循环会等待直到栈为空。
2. 执行微任务：执行栈为空时，事件循环会检查微任务队列，并执行其中的所有微任务。
3. 执行宏任务：当微任务队列为空时，事件循环会检查宏任务队列，并取出第一个执行。

## 微任务与宏任务
微任务（microtasks）和宏任务（macrotasks）是浏览器事件循环中的两种任务类型。微任务通常包括Promise的回调函数和MutationObserver，而宏任务则包括setTimeout、setInterval、DOM事件等。微任务会在当前宏任务执行完毕后立即执行，而宏任务则会在事件循环的下一个迭代中执行。

## 总结
浏览器环境中的异步操作由浏览器内置的Web API处理，并通过事件循环机制将结果返回给JavaScript。JavaScript代码执行、事件处理程序和回调函数的执行都由
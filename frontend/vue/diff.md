# diff
## React-Diff
1. 思路：递增法。通过对比新的列表中的节点，在原来列表中的位置是否递增，来判断当前的节点是否需要移动。
核心：通过维护一个"最大索引值"来判断节点是否需要移动：
- 如果当前节点在旧列表中的位置 >= 最大索引值：不需要移动，更新最大索引值
- 如果当前节点在旧列表中的位置 < 最大索引值：需要移动


旧列表: [A, B, C, D]
新列表: [A, D, B, C]
处理过程：
1. A: 旧索引0, 最大索引0 → 0>=0 不移动，最大索引=0
2. D: 旧索引3, 最大索引0 → 3>=0 不移动，最大索引=3  
3. B: 旧索引1, 最大索引3 → 1<3 需要移动！
4. C: 旧索引2, 最大索引3 → 2<3 需要移动！

其实就是从新列表里开始排，如果发现某个节点在旧列表中的位置比上一个节点的旧位置小，那么就需要移动。大小只是一个已知条件，移动与否取决于新旧列表的相对位置。

## Vue2-双端diff
1. 思路：新旧列表的头尾同时比较，向中间靠拢。
核心：通过维护两个指针分别指向旧列表和新列表的开始和结束位置，然后进行比较，并根据比较结果进行相应的DOM移动或替换操作。
- 比较头尾元素是否相同，如果相同则继续前进；
- 如果不同，则在旧列表中查找是否存在与新列表当前位置的节点相同的元素，并找到该元素的索引值；
- 根据这个索引值决定是移动还是替换当前的节点。

### 举例说明
旧列表: [A, B, C, D]
新列表: [D, B, A, C]
处理过程：
1. 开始时，旧列表的头部为A，新列表的头部也为A，两者相同，都向后移一位。
2. 然后发现B在新列表中的位置比在旧列表中的位置要小（即在旧列表中没有找到与之对应的节点），因此需要将B从旧列表中删除，并在新列表的位置插入B。
3. 以此类推，直到所有元素都被正确放置为止。

## Vue3-最长递增子序列优化diff
1. 思路：最长递增子序列算法 + 双端对比
核心：通过最长递增子序列（LIS）算法，找到新旧列表中可以形成最长匹配的节点序列。

## React-Fiber
1. 思路：增量渲染
核心：将更新过程拆分成多个小任务，每个任务执行一小部分工作后暂停，然后继续下一个任务。这样可以避免长时间占用主线程导致页面卡顿的问题。
- 使用Fiber节点作为虚拟DOM的替代品，每个Fiber节点代表一个组件或元素；
- 通过调度器（Scheduler）来安排任务的优先级和执行顺序；
- 使用workInProgress树来表示当前正在处理的更新状态，并与旧的tree进行比较以生成实际的DOM变更。

其实际更新dom的算法还是基于上面提到的几种算法，但是通过Fiber架构实现了增量渲染和更细粒度的控制。

vue3同步渲染 + 编译时优化


## 在处理更新视图问题vue和react的区别
React: 运行时解决问题 (时间切片)
Vue3: 编译时解决问题 (静态分析)